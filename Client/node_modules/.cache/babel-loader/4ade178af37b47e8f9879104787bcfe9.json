{"ast":null,"code":"'use strict';\n\nconst WS = require('ws');\n\nconst debug = require('debug')('mqttjs:ws');\n\nconst duplexify = require('duplexify');\n\nconst Transform = require('readable-stream').Transform;\n\nconst WSS_OPTIONS = ['rejectUnauthorized', 'ca', 'cert', 'key', 'pfx', 'passphrase']; // eslint-disable-next-line camelcase\n\nconst IS_BROWSER = typeof process !== 'undefined' && process.title === 'browser' || typeof __webpack_require__ === 'function';\n\nfunction buildUrl(opts, client) {\n  let url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n\n  if (typeof opts.transformWsUrl === 'function') {\n    url = opts.transformWsUrl(url, opts, client);\n  }\n\n  return url;\n}\n\nfunction setDefaultOpts(opts) {\n  const options = opts;\n\n  if (!opts.hostname) {\n    options.hostname = 'localhost';\n  }\n\n  if (!opts.port) {\n    if (opts.protocol === 'wss') {\n      options.port = 443;\n    } else {\n      options.port = 80;\n    }\n  }\n\n  if (!opts.path) {\n    options.path = '/';\n  }\n\n  if (!opts.wsOptions) {\n    options.wsOptions = {};\n  }\n\n  if (!IS_BROWSER && opts.protocol === 'wss') {\n    // Add cert/key/ca etc options\n    WSS_OPTIONS.forEach(function (prop) {\n      if (Object.prototype.hasOwnProperty.call(opts, prop) && !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {\n        options.wsOptions[prop] = opts[prop];\n      }\n    });\n  }\n\n  return options;\n}\n\nfunction setDefaultBrowserOpts(opts) {\n  const options = setDefaultOpts(opts);\n\n  if (!options.hostname) {\n    options.hostname = options.host;\n  }\n\n  if (!options.hostname) {\n    // Throwing an error in a Web Worker if no `hostname` is given, because we\n    // can not determine the `hostname` automatically.  If connecting to\n    // localhost, please supply the `hostname` as an argument.\n    if (typeof document === 'undefined') {\n      throw new Error('Could not determine host. Specify host manually.');\n    }\n\n    const parsed = new URL(document.URL);\n    options.hostname = parsed.hostname;\n\n    if (!options.port) {\n      options.port = parsed.port;\n    }\n  } // objectMode should be defined for logic\n\n\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined);\n  }\n\n  return options;\n}\n\nfunction createWebSocket(client, url, opts) {\n  debug('createWebSocket');\n  debug('protocol: ' + opts.protocolId + ' ' + opts.protocolVersion);\n  const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n  debug('creating new Websocket for url: ' + url + ' and protocol: ' + websocketSubProtocol);\n  const socket = new WS(url, [websocketSubProtocol], opts.wsOptions);\n  return socket;\n}\n\nfunction createBrowserWebSocket(client, opts) {\n  const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n  const url = buildUrl(opts, client);\n  /* global WebSocket */\n\n  const socket = new WebSocket(url, [websocketSubProtocol]);\n  socket.binaryType = 'arraybuffer';\n  return socket;\n}\n\nfunction streamBuilder(client, opts) {\n  debug('streamBuilder');\n  const options = setDefaultOpts(opts);\n  const url = buildUrl(options, client);\n  const socket = createWebSocket(client, url, options);\n  const webSocketStream = WS.createWebSocketStream(socket, options.wsOptions);\n  webSocketStream.url = url;\n  socket.on('close', () => {\n    webSocketStream.destroy();\n  });\n  return webSocketStream;\n}\n\nfunction browserStreamBuilder(client, opts) {\n  debug('browserStreamBuilder');\n  let stream;\n  const options = setDefaultBrowserOpts(opts); // sets the maximum socket buffer size before throttling\n\n  const bufferSize = options.browserBufferSize || 1024 * 512;\n  const bufferTimeout = opts.browserBufferTimeout || 1000;\n  const coerceToBuffer = !opts.objectMode;\n  const socket = createBrowserWebSocket(client, opts);\n  const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);\n\n  if (!opts.objectMode) {\n    proxy._writev = writev;\n  }\n\n  proxy.on('close', () => {\n    socket.close();\n  });\n  const eventListenerSupport = typeof socket.addEventListener !== 'undefined'; // was already open when passed in\n\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy;\n  } else {\n    stream = stream = duplexify(undefined, undefined, opts);\n\n    if (!opts.objectMode) {\n      stream._writev = writev;\n    }\n\n    if (eventListenerSupport) {\n      socket.addEventListener('open', onopen);\n    } else {\n      socket.onopen = onopen;\n    }\n  }\n\n  stream.socket = socket;\n\n  if (eventListenerSupport) {\n    socket.addEventListener('close', onclose);\n    socket.addEventListener('error', onerror);\n    socket.addEventListener('message', onmessage);\n  } else {\n    socket.onclose = onclose;\n    socket.onerror = onerror;\n    socket.onmessage = onmessage;\n  } // methods for browserStreamBuilder\n\n\n  function buildProxy(options, socketWrite, socketEnd) {\n    const proxy = new Transform({\n      objectModeMode: options.objectMode\n    });\n    proxy._write = socketWrite;\n    proxy._flush = socketEnd;\n    return proxy;\n  }\n\n  function onopen() {\n    stream.setReadable(proxy);\n    stream.setWritable(proxy);\n    stream.emit('connect');\n  }\n\n  function onclose() {\n    stream.end();\n    stream.destroy();\n  }\n\n  function onerror(err) {\n    stream.destroy(err);\n  }\n\n  function onmessage(event) {\n    let data = event.data;\n    if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n    proxy.push(data);\n  } // this is to be enabled only if objectMode is false\n\n\n  function writev(chunks, cb) {\n    const buffers = new Array(chunks.length);\n\n    for (let i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8');\n      } else {\n        buffers[i] = chunks[i].chunk;\n      }\n    }\n\n    this._write(Buffer.concat(buffers), 'binary', cb);\n  }\n\n  function socketWriteBrowser(chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      // throttle data until buffered amount is reduced.\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8');\n    }\n\n    try {\n      socket.send(chunk);\n    } catch (err) {\n      return next(err);\n    }\n\n    next();\n  }\n\n  function socketEndBrowser(done) {\n    socket.close();\n    done();\n  } // end methods for browserStreamBuilder\n\n\n  return stream;\n}\n\nif (IS_BROWSER) {\n  module.exports = browserStreamBuilder;\n} else {\n  module.exports = streamBuilder;\n}","map":{"version":3,"sources":["/home/labinf/exam-call-1-oxhunt/Client/node_modules/mqtt/lib/connect/ws.js"],"names":["WS","require","debug","duplexify","Transform","WSS_OPTIONS","IS_BROWSER","process","title","__webpack_require__","buildUrl","opts","client","url","protocol","hostname","port","path","transformWsUrl","setDefaultOpts","options","wsOptions","forEach","prop","Object","prototype","hasOwnProperty","call","setDefaultBrowserOpts","host","document","Error","parsed","URL","objectMode","undefined","binary","createWebSocket","protocolId","protocolVersion","websocketSubProtocol","socket","createBrowserWebSocket","WebSocket","binaryType","streamBuilder","webSocketStream","createWebSocketStream","on","destroy","browserStreamBuilder","stream","bufferSize","browserBufferSize","bufferTimeout","browserBufferTimeout","coerceToBuffer","proxy","buildProxy","socketWriteBrowser","socketEndBrowser","_writev","writev","close","eventListenerSupport","addEventListener","readyState","OPEN","onopen","onclose","onerror","onmessage","socketWrite","socketEnd","objectModeMode","_write","_flush","setReadable","setWritable","emit","end","err","event","data","ArrayBuffer","Buffer","from","push","chunks","cb","buffers","Array","length","i","chunk","concat","enc","next","bufferedAmount","setTimeout","send","done","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst WS = require('ws')\nconst debug = require('debug')('mqttjs:ws')\nconst duplexify = require('duplexify')\nconst Transform = require('readable-stream').Transform\n\nconst WSS_OPTIONS = [\n  'rejectUnauthorized',\n  'ca',\n  'cert',\n  'key',\n  'pfx',\n  'passphrase'\n]\n// eslint-disable-next-line camelcase\nconst IS_BROWSER = (typeof process !== 'undefined' && process.title === 'browser') || typeof __webpack_require__ === 'function'\nfunction buildUrl (opts, client) {\n  let url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path\n  if (typeof (opts.transformWsUrl) === 'function') {\n    url = opts.transformWsUrl(url, opts, client)\n  }\n  return url\n}\n\nfunction setDefaultOpts (opts) {\n  const options = opts\n  if (!opts.hostname) {\n    options.hostname = 'localhost'\n  }\n  if (!opts.port) {\n    if (opts.protocol === 'wss') {\n      options.port = 443\n    } else {\n      options.port = 80\n    }\n  }\n  if (!opts.path) {\n    options.path = '/'\n  }\n\n  if (!opts.wsOptions) {\n    options.wsOptions = {}\n  }\n  if (!IS_BROWSER && opts.protocol === 'wss') {\n    // Add cert/key/ca etc options\n    WSS_OPTIONS.forEach(function (prop) {\n      if (Object.prototype.hasOwnProperty.call(opts, prop) && !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {\n        options.wsOptions[prop] = opts[prop]\n      }\n    })\n  }\n\n  return options\n}\n\nfunction setDefaultBrowserOpts (opts) {\n  const options = setDefaultOpts(opts)\n\n  if (!options.hostname) {\n    options.hostname = options.host\n  }\n\n  if (!options.hostname) {\n    // Throwing an error in a Web Worker if no `hostname` is given, because we\n    // can not determine the `hostname` automatically.  If connecting to\n    // localhost, please supply the `hostname` as an argument.\n    if (typeof (document) === 'undefined') {\n      throw new Error('Could not determine host. Specify host manually.')\n    }\n    const parsed = new URL(document.URL)\n    options.hostname = parsed.hostname\n\n    if (!options.port) {\n      options.port = parsed.port\n    }\n  }\n\n  // objectMode should be defined for logic\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined)\n  }\n\n  return options\n}\n\nfunction createWebSocket (client, url, opts) {\n  debug('createWebSocket')\n  debug('protocol: ' + opts.protocolId + ' ' + opts.protocolVersion)\n  const websocketSubProtocol =\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n      ? 'mqttv3.1'\n      : 'mqtt'\n\n  debug('creating new Websocket for url: ' + url + ' and protocol: ' + websocketSubProtocol)\n  const socket = new WS(url, [websocketSubProtocol], opts.wsOptions)\n  return socket\n}\n\nfunction createBrowserWebSocket (client, opts) {\n  const websocketSubProtocol =\n  (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n    ? 'mqttv3.1'\n    : 'mqtt'\n\n  const url = buildUrl(opts, client)\n  /* global WebSocket */\n  const socket = new WebSocket(url, [websocketSubProtocol])\n  socket.binaryType = 'arraybuffer'\n  return socket\n}\n\nfunction streamBuilder (client, opts) {\n  debug('streamBuilder')\n  const options = setDefaultOpts(opts)\n  const url = buildUrl(options, client)\n  const socket = createWebSocket(client, url, options)\n  const webSocketStream = WS.createWebSocketStream(socket, options.wsOptions)\n  webSocketStream.url = url\n  socket.on('close', () => { webSocketStream.destroy() })\n  return webSocketStream\n}\n\nfunction browserStreamBuilder (client, opts) {\n  debug('browserStreamBuilder')\n  let stream\n  const options = setDefaultBrowserOpts(opts)\n  // sets the maximum socket buffer size before throttling\n  const bufferSize = options.browserBufferSize || 1024 * 512\n\n  const bufferTimeout = opts.browserBufferTimeout || 1000\n\n  const coerceToBuffer = !opts.objectMode\n\n  const socket = createBrowserWebSocket(client, opts)\n\n  const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser)\n\n  if (!opts.objectMode) {\n    proxy._writev = writev\n  }\n  proxy.on('close', () => { socket.close() })\n\n  const eventListenerSupport = (typeof socket.addEventListener !== 'undefined')\n\n  // was already open when passed in\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy\n  } else {\n    stream = stream = duplexify(undefined, undefined, opts)\n    if (!opts.objectMode) {\n      stream._writev = writev\n    }\n\n    if (eventListenerSupport) {\n      socket.addEventListener('open', onopen)\n    } else {\n      socket.onopen = onopen\n    }\n  }\n\n  stream.socket = socket\n\n  if (eventListenerSupport) {\n    socket.addEventListener('close', onclose)\n    socket.addEventListener('error', onerror)\n    socket.addEventListener('message', onmessage)\n  } else {\n    socket.onclose = onclose\n    socket.onerror = onerror\n    socket.onmessage = onmessage\n  }\n\n  // methods for browserStreamBuilder\n\n  function buildProxy (options, socketWrite, socketEnd) {\n    const proxy = new Transform({\n      objectModeMode: options.objectMode\n    })\n\n    proxy._write = socketWrite\n    proxy._flush = socketEnd\n\n    return proxy\n  }\n\n  function onopen () {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  }\n\n  function onclose () {\n    stream.end()\n    stream.destroy()\n  }\n\n  function onerror (err) {\n    stream.destroy(err)\n  }\n\n  function onmessage (event) {\n    let data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    else data = Buffer.from(data, 'utf8')\n    proxy.push(data)\n  }\n\n  // this is to be enabled only if objectMode is false\n  function writev (chunks, cb) {\n    const buffers = new Array(chunks.length)\n    for (let i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8')\n      } else {\n        buffers[i] = chunks[i].chunk\n      }\n    }\n\n    this._write(Buffer.concat(buffers), 'binary', cb)\n  }\n\n  function socketWriteBrowser (chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      // throttle data until buffered amount is reduced.\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n\n    try {\n      socket.send(chunk)\n    } catch (err) {\n      return next(err)\n    }\n\n    next()\n  }\n\n  function socketEndBrowser (done) {\n    socket.close()\n    done()\n  }\n\n  // end methods for browserStreamBuilder\n\n  return stream\n}\n\nif (IS_BROWSER) {\n  module.exports = browserStreamBuilder\n} else {\n  module.exports = streamBuilder\n}\n"]},"metadata":{},"sourceType":"script"}