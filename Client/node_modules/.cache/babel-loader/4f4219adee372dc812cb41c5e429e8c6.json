{"ast":null,"code":"// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n'use strict';\n\nconst SortedSet = require('js-sdsl').Set;\n\nconst debugTrace = require('debug')('number-allocator:trace');\n\nconst debugError = require('debug')('number-allocator:error');\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\n\n\nfunction Interval(low, high) {\n  this.low = low;\n  this.high = high;\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high;\n};\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1;\n  if (other.low < this.low && other.high < this.low) return 1;\n  return 0;\n};\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\n\n\nfunction NumberAllocator(min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max);\n  }\n\n  this.min = min;\n  this.max = max;\n  this.ss = new SortedSet([], (lhs, rhs) => {\n    return lhs.compare(rhs);\n  });\n  debugTrace('Create');\n  this.clear();\n}\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\n\n\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null;\n  return this.ss.front().low;\n};\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\n\n\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty');\n    return null;\n  }\n\n  const it = this.ss.front();\n  const num = it.low;\n\n  if (num + 1 <= it.high) {\n    // Overwrite the interval in the ss but it is safe,\n    // because no order violation is happened.\n    // x|----|\n    ++it.low;\n  } else {\n    this.ss.eraseElementByPos(0);\n  }\n\n  debugTrace('alloc():' + num);\n  return num;\n};\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\n\n\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num);\n  const it = this.ss.lowerBound(key);\n\n  if (it) {\n    if (it.equals(key)) {\n      // |x|\n      this.ss.eraseElementByValue(it);\n      debugTrace('use():' + num);\n      return true;\n    } // x |-----|\n\n\n    if (it.low > num) return false; // |x----|\n\n    if (it.low === num) {\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      // x|----|\n      ++it.low;\n      debugTrace('use():' + num);\n      return true;\n    } // |----x|\n\n\n    if (it.high === num) {\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      // |----|x\n      --it.high;\n      debugTrace('use():' + num);\n      return true;\n    }\n\n    const low = it.low; // |--x--|\n    // Overwrite the interval in the ss but it is safe,\n    // because no order violation is happened.\n    // x|--|\n\n    it.low = num + 1; // |--|x|--|\n\n    this.ss.insert(new Interval(low, num - 1));\n    debugTrace('use():' + num);\n    return true;\n  }\n\n  debugTrace('use():failed');\n  return false;\n};\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\n\n\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range');\n    return;\n  }\n\n  const key = new Interval(num, num);\n  const it = this.ss.lowerBound(key);\n\n  if (it) {\n    if (it.low <= num && num <= it.high) {\n      debugError('free():' + num + ' has already been vacant');\n      return;\n    }\n\n    if (it === this.ss.front()) {\n      // v....\n      if (num + 1 === it.low) {\n        // Concat to right\n        // Overwrite the interval in the ss but it is safe,\n        // because no order violation is happened.\n        --it.low;\n      } else {\n        // Insert new interval\n        this.ss.insert(key);\n      }\n    } else {\n      // ..v..\n      const itl = this.ss.reverseLowerBound(key);\n\n      if (itl.high + 1 === num) {\n        if (num + 1 === it.low) {\n          // Concat to left and right\n          this.ss.eraseElementByValue(itl); // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n\n          it.low = itl.low;\n        } else {\n          // Concat to left\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          itl.high = num;\n        }\n      } else {\n        if (num + 1 === it.low) {\n          // Concat to right\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          it.low = num;\n        } else {\n          // Insert new interval\n          this.ss.insert(key);\n        }\n      }\n    }\n  } else {\n    // ....v\n    if (it === this.ss.front()) {\n      // Insert new interval\n      this.ss.insert(key);\n      return;\n    }\n\n    const itl = this.ss.reverseLowerBound(key);\n\n    if (itl.high + 1 === num) {\n      // Concat to left\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      itl.high = num;\n    } else {\n      // Insert new interval\n      this.ss.insert(key);\n    }\n  }\n\n  debugTrace('free():' + num);\n};\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\n\n\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()');\n  this.ss.clear();\n  this.ss.insert(new Interval(this.min, this.max));\n};\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\n\n\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size();\n};\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\n\n\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size());\n\n  for (const element of this.ss) {\n    console.log(element);\n  }\n};\n\nmodule.exports = NumberAllocator;","map":{"version":3,"sources":["/home/labinf/exam-call-1-oxhunt/Client/node_modules/number-allocator/lib/number-allocator.js"],"names":["SortedSet","require","Set","debugTrace","debugError","Interval","low","high","prototype","equals","other","compare","NumberAllocator","min","max","ss","lhs","rhs","clear","firstVacant","size","front","alloc","it","num","eraseElementByPos","use","key","lowerBound","eraseElementByValue","insert","free","itl","reverseLowerBound","intervalCount","dump","console","log","element","module","exports"],"mappings":"AAAA;AACA;AACA;AAEA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBC,GAArC;;AACA,MAAMC,UAAU,GAAGF,OAAO,CAAC,OAAD,CAAP,CAAiB,wBAAjB,CAAnB;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,OAAD,CAAP,CAAiB,wBAAjB,CAAnB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,QAAT,CAAmBC,GAAnB,EAAwBC,IAAxB,EAA8B;AAC5B,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKC,IAAL,GAAYA,IAAZ;AACD;;AAEDF,QAAQ,CAACG,SAAT,CAAmBC,MAAnB,GAA4B,UAAUC,KAAV,EAAiB;AAC3C,SAAO,KAAKJ,GAAL,KAAaI,KAAK,CAACJ,GAAnB,IAA0B,KAAKC,IAAL,KAAcG,KAAK,CAACH,IAArD;AACD,CAFD;;AAIAF,QAAQ,CAACG,SAAT,CAAmBG,OAAnB,GAA6B,UAAUD,KAAV,EAAiB;AAC5C,MAAI,KAAKJ,GAAL,GAAWI,KAAK,CAACJ,GAAjB,IAAwB,KAAKC,IAAL,GAAYG,KAAK,CAACJ,GAA9C,EAAmD,OAAO,CAAC,CAAR;AACnD,MAAII,KAAK,CAACJ,GAAN,GAAY,KAAKA,GAAjB,IAAwBI,KAAK,CAACH,IAAN,GAAa,KAAKD,GAA9C,EAAmD,OAAO,CAAP;AACnD,SAAO,CAAP;AACD,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,eAAT,CAA0BC,GAA1B,EAA+BC,GAA/B,EAAoC;AAClC,MAAI,EAAE,gBAAgBF,eAAlB,CAAJ,EAAwC;AACtC,WAAO,IAAIA,eAAJ,CAAoBC,GAApB,EAAyBC,GAAzB,CAAP;AACD;;AAED,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKC,GAAL,GAAWA,GAAX;AAEA,OAAKC,EAAL,GAAU,IAAIf,SAAJ,CACR,EADQ,EAER,CAACgB,GAAD,EAAMC,GAAN,KAAc;AACZ,WAAOD,GAAG,CAACL,OAAJ,CAAYM,GAAZ,CAAP;AACD,GAJO,CAAV;AAMAd,EAAAA,UAAU,CAAC,QAAD,CAAV;AACA,OAAKe,KAAL;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAN,eAAe,CAACJ,SAAhB,CAA0BW,WAA1B,GAAwC,YAAY;AAClD,MAAI,KAAKJ,EAAL,CAAQK,IAAR,OAAmB,CAAvB,EAA0B,OAAO,IAAP;AAC1B,SAAO,KAAKL,EAAL,CAAQM,KAAR,GAAgBf,GAAvB;AACD,CAHD;AAKA;AACA;AACA;AACA;AACA;;;AACAM,eAAe,CAACJ,SAAhB,CAA0Bc,KAA1B,GAAkC,YAAY;AAC5C,MAAI,KAAKP,EAAL,CAAQK,IAAR,OAAmB,CAAvB,EAA0B;AACxBjB,IAAAA,UAAU,CAAC,eAAD,CAAV;AACA,WAAO,IAAP;AACD;;AACD,QAAMoB,EAAE,GAAG,KAAKR,EAAL,CAAQM,KAAR,EAAX;AACA,QAAMG,GAAG,GAAGD,EAAE,CAACjB,GAAf;;AACA,MAAIkB,GAAG,GAAG,CAAN,IAAWD,EAAE,CAAChB,IAAlB,EAAwB;AACtB;AACA;AACA;AACA,MAAEgB,EAAE,CAACjB,GAAL;AACD,GALD,MAKO;AACL,SAAKS,EAAL,CAAQU,iBAAR,CAA0B,CAA1B;AACD;;AACDtB,EAAAA,UAAU,CAAC,aAAaqB,GAAd,CAAV;AACA,SAAOA,GAAP;AACD,CAjBD;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAZ,eAAe,CAACJ,SAAhB,CAA0BkB,GAA1B,GAAgC,UAAUF,GAAV,EAAe;AAC7C,QAAMG,GAAG,GAAG,IAAItB,QAAJ,CAAamB,GAAb,EAAkBA,GAAlB,CAAZ;AACA,QAAMD,EAAE,GAAG,KAAKR,EAAL,CAAQa,UAAR,CAAmBD,GAAnB,CAAX;;AACA,MAAIJ,EAAJ,EAAQ;AACN,QAAIA,EAAE,CAACd,MAAH,CAAUkB,GAAV,CAAJ,EAAoB;AAClB;AACA,WAAKZ,EAAL,CAAQc,mBAAR,CAA4BN,EAA5B;AACApB,MAAAA,UAAU,CAAC,WAAWqB,GAAZ,CAAV;AACA,aAAO,IAAP;AACD,KANK,CAQN;;;AACA,QAAID,EAAE,CAACjB,GAAH,GAASkB,GAAb,EAAkB,OAAO,KAAP,CATZ,CAWN;;AACA,QAAID,EAAE,CAACjB,GAAH,KAAWkB,GAAf,EAAoB;AAClB;AACA;AACA;AACA,QAAED,EAAE,CAACjB,GAAL;AACAH,MAAAA,UAAU,CAAC,WAAWqB,GAAZ,CAAV;AACA,aAAO,IAAP;AACD,KAnBK,CAqBN;;;AACA,QAAID,EAAE,CAAChB,IAAH,KAAYiB,GAAhB,EAAqB;AACnB;AACA;AACA;AACA,QAAED,EAAE,CAAChB,IAAL;AACAJ,MAAAA,UAAU,CAAC,WAAWqB,GAAZ,CAAV;AACA,aAAO,IAAP;AACD;;AAED,UAAMlB,GAAG,GAAGiB,EAAE,CAACjB,GAAf,CA/BM,CAiCN;AACA;AACA;AACA;;AACAiB,IAAAA,EAAE,CAACjB,GAAH,GAASkB,GAAG,GAAG,CAAf,CArCM,CAuCN;;AACA,SAAKT,EAAL,CAAQe,MAAR,CAAe,IAAIzB,QAAJ,CAAaC,GAAb,EAAkBkB,GAAG,GAAG,CAAxB,CAAf;AACArB,IAAAA,UAAU,CAAC,WAAWqB,GAAZ,CAAV;AACA,WAAO,IAAP;AACD;;AAEDrB,EAAAA,UAAU,CAAC,cAAD,CAAV;AACA,SAAO,KAAP;AACD,CAlDD;AAoDA;AACA;AACA;AACA;AACA;AACA;;;AACAS,eAAe,CAACJ,SAAhB,CAA0BuB,IAA1B,GAAiC,UAAUP,GAAV,EAAe;AAC9C,MAAIA,GAAG,GAAG,KAAKX,GAAX,IAAkBW,GAAG,GAAG,KAAKV,GAAjC,EAAsC;AACpCV,IAAAA,UAAU,CAAC,YAAYoB,GAAZ,GAAkB,kBAAnB,CAAV;AACA;AACD;;AACD,QAAMG,GAAG,GAAG,IAAItB,QAAJ,CAAamB,GAAb,EAAkBA,GAAlB,CAAZ;AACA,QAAMD,EAAE,GAAG,KAAKR,EAAL,CAAQa,UAAR,CAAmBD,GAAnB,CAAX;;AACA,MAAIJ,EAAJ,EAAQ;AACN,QAAIA,EAAE,CAACjB,GAAH,IAAUkB,GAAV,IAAiBA,GAAG,IAAID,EAAE,CAAChB,IAA/B,EAAqC;AACnCH,MAAAA,UAAU,CAAC,YAAYoB,GAAZ,GAAkB,0BAAnB,CAAV;AACA;AACD;;AACD,QAAID,EAAE,KAAK,KAAKR,EAAL,CAAQM,KAAR,EAAX,EAA4B;AAC1B;AACA,UAAIG,GAAG,GAAG,CAAN,KAAYD,EAAE,CAACjB,GAAnB,EAAwB;AACtB;AACA;AACA;AACA,UAAEiB,EAAE,CAACjB,GAAL;AACD,OALD,MAKO;AACL;AACA,aAAKS,EAAL,CAAQe,MAAR,CAAeH,GAAf;AACD;AACF,KAXD,MAWO;AACL;AACA,YAAMK,GAAG,GAAG,KAAKjB,EAAL,CAAQkB,iBAAR,CAA0BN,GAA1B,CAAZ;;AACA,UAAIK,GAAG,CAACzB,IAAJ,GAAW,CAAX,KAAiBiB,GAArB,EAA0B;AACxB,YAAIA,GAAG,GAAG,CAAN,KAAYD,EAAE,CAACjB,GAAnB,EAAwB;AACtB;AACA,eAAKS,EAAL,CAAQc,mBAAR,CAA4BG,GAA5B,EAFsB,CAGtB;AACA;;AACAT,UAAAA,EAAE,CAACjB,GAAH,GAAS0B,GAAG,CAAC1B,GAAb;AACD,SAND,MAMO;AACL;AACA;AACA;AACA0B,UAAAA,GAAG,CAACzB,IAAJ,GAAWiB,GAAX;AACD;AACF,OAbD,MAaO;AACL,YAAIA,GAAG,GAAG,CAAN,KAAYD,EAAE,CAACjB,GAAnB,EAAwB;AACtB;AACA;AACA;AACAiB,UAAAA,EAAE,CAACjB,GAAH,GAASkB,GAAT;AACD,SALD,MAKO;AACL;AACA,eAAKT,EAAL,CAAQe,MAAR,CAAeH,GAAf;AACD;AACF;AACF;AACF,GA5CD,MA4CO;AACL;AACA,QAAIJ,EAAE,KAAK,KAAKR,EAAL,CAAQM,KAAR,EAAX,EAA4B;AAC1B;AACA,WAAKN,EAAL,CAAQe,MAAR,CAAeH,GAAf;AACA;AACD;;AACD,UAAMK,GAAG,GAAG,KAAKjB,EAAL,CAAQkB,iBAAR,CAA0BN,GAA1B,CAAZ;;AACA,QAAIK,GAAG,CAACzB,IAAJ,GAAW,CAAX,KAAiBiB,GAArB,EAA0B;AACxB;AACA;AACA;AACAQ,MAAAA,GAAG,CAACzB,IAAJ,GAAWiB,GAAX;AACD,KALD,MAKO;AACL;AACA,WAAKT,EAAL,CAAQe,MAAR,CAAeH,GAAf;AACD;AACF;;AACDxB,EAAAA,UAAU,CAAC,YAAYqB,GAAb,CAAV;AACD,CAtED;AAwEA;AACA;AACA;AACA;AACA;;;AACAZ,eAAe,CAACJ,SAAhB,CAA0BU,KAA1B,GAAkC,YAAY;AAC5Cf,EAAAA,UAAU,CAAC,SAAD,CAAV;AACA,OAAKY,EAAL,CAAQG,KAAR;AACA,OAAKH,EAAL,CAAQe,MAAR,CAAe,IAAIzB,QAAJ,CAAa,KAAKQ,GAAlB,EAAuB,KAAKC,GAA5B,CAAf;AACD,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;;;AACAF,eAAe,CAACJ,SAAhB,CAA0B0B,aAA1B,GAA0C,YAAY;AACpD,SAAO,KAAKnB,EAAL,CAAQK,IAAR,EAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAR,eAAe,CAACJ,SAAhB,CAA0B2B,IAA1B,GAAiC,YAAY;AAC3CC,EAAAA,OAAO,CAACC,GAAR,CAAY,YAAY,KAAKtB,EAAL,CAAQK,IAAR,EAAxB;;AACA,OAAK,MAAMkB,OAAX,IAAsB,KAAKvB,EAA3B,EAA+B;AAC7BqB,IAAAA,OAAO,CAACC,GAAR,CAAYC,OAAZ;AACD;AACF,CALD;;AAOAC,MAAM,CAACC,OAAP,GAAiB5B,eAAjB","sourcesContent":["// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\n'use strict'\n\nconst SortedSet = require('js-sdsl').Set\nconst debugTrace = require('debug')('number-allocator:trace')\nconst debugError = require('debug')('number-allocator:error')\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\nfunction Interval (low, high) {\n  this.low = low\n  this.high = high\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high\n}\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1\n  if (other.low < this.low && other.high < this.low) return 1\n  return 0\n}\n\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\nfunction NumberAllocator (min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max)\n  }\n\n  this.min = min\n  this.max = max\n\n  this.ss = new SortedSet(\n    [],\n    (lhs, rhs) => {\n      return lhs.compare(rhs)\n    }\n  )\n  debugTrace('Create')\n  this.clear()\n}\n\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null\n  return this.ss.front().low\n}\n\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty')\n    return null\n  }\n  const it = this.ss.front()\n  const num = it.low\n  if (num + 1 <= it.high) {\n    // Overwrite the interval in the ss but it is safe,\n    // because no order violation is happened.\n    // x|----|\n    ++it.low\n  } else {\n    this.ss.eraseElementByPos(0)\n  }\n  debugTrace('alloc():' + num)\n  return num\n}\n\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num)\n  const it = this.ss.lowerBound(key)\n  if (it) {\n    if (it.equals(key)) {\n      // |x|\n      this.ss.eraseElementByValue(it)\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // x |-----|\n    if (it.low > num) return false\n\n    // |x----|\n    if (it.low === num) {\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      // x|----|\n      ++it.low\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |----x|\n    if (it.high === num) {\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      // |----|x\n      --it.high\n      debugTrace('use():' + num)\n      return true\n    }\n\n    const low = it.low\n\n    // |--x--|\n    // Overwrite the interval in the ss but it is safe,\n    // because no order violation is happened.\n    // x|--|\n    it.low = num + 1\n\n    // |--|x|--|\n    this.ss.insert(new Interval(low, num - 1))\n    debugTrace('use():' + num)\n    return true\n  }\n\n  debugTrace('use():failed')\n  return false\n}\n\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range')\n    return\n  }\n  const key = new Interval(num, num)\n  const it = this.ss.lowerBound(key)\n  if (it) {\n    if (it.low <= num && num <= it.high) {\n      debugError('free():' + num + ' has already been vacant')\n      return\n    }\n    if (it === this.ss.front()) {\n      // v....\n      if (num + 1 === it.low) {\n        // Concat to right\n        // Overwrite the interval in the ss but it is safe,\n        // because no order violation is happened.\n        --it.low\n      } else {\n        // Insert new interval\n        this.ss.insert(key)\n      }\n    } else {\n      // ..v..\n      const itl = this.ss.reverseLowerBound(key)\n      if (itl.high + 1 === num) {\n        if (num + 1 === it.low) {\n          // Concat to left and right\n          this.ss.eraseElementByValue(itl)\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          it.low = itl.low\n        } else {\n          // Concat to left\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          itl.high = num\n        }\n      } else {\n        if (num + 1 === it.low) {\n          // Concat to right\n          // Overwrite the interval in the ss but it is safe,\n          // because no order violation is happened.\n          it.low = num\n        } else {\n          // Insert new interval\n          this.ss.insert(key)\n        }\n      }\n    }\n  } else {\n    // ....v\n    if (it === this.ss.front()) {\n      // Insert new interval\n      this.ss.insert(key)\n      return\n    }\n    const itl = this.ss.reverseLowerBound(key)\n    if (itl.high + 1 === num) {\n      // Concat to left\n      // Overwrite the interval in the ss but it is safe,\n      // because no order violation is happened.\n      itl.high = num\n    } else {\n      // Insert new interval\n      this.ss.insert(key)\n    }\n  }\n  debugTrace('free():' + num)\n}\n\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()')\n  this.ss.clear()\n  this.ss.insert(new Interval(this.min, this.max))\n}\n\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size()\n}\n\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size())\n  for (const element of this.ss) {\n    console.log(element)\n  }\n}\n\nmodule.exports = NumberAllocator\n"]},"metadata":{},"sourceType":"script"}